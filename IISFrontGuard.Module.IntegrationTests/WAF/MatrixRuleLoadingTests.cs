using IISFrontGuard.Module.Abstractions;
using IISFrontGuard.Module.Services;
using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.IO;
using System.Linq;
using Xunit;
using Xunit.Abstractions;

namespace IISFrontGuard.Module.IntegrationTests.WAF
{
    /// <summary>
    /// Integration tests for the matrix of WAF rules generated by the SQL script.
    /// Tests loading and compilation of all Field x Operator combinations (~550 rules).
    /// Automatically sets up test data before tests and cleans up after.
    /// </summary>
    [Collection("IIS Integration Tests")]
    public class MatrixRuleLoadingTests : IDisposable
    {
        private readonly ICacheProvider _tokenCache;
        private readonly IWafRuleRepository _wafRuleRepository;
        private readonly ITestOutputHelper _output;
        private readonly string _connectionString;
        private static bool _dataSetupComplete = false;
        private static readonly object _setupLock = new object();

        public MatrixRuleLoadingTests(ITestOutputHelper output)
        {
            _output = output;
            _tokenCache = new HttpRuntimeCacheProvider();
            _wafRuleRepository = new WafRuleRepository(_tokenCache);

            _connectionString = System.Configuration.ConfigurationManager.ConnectionStrings["IISFrontGuardConnection"]?.ConnectionString
                ?? "Server=(local);Database=IISFrontGuard;Integrated Security=true;Connection Timeout=30;";

            // Setup test data once for all tests in this class
            lock (_setupLock)
            {
                if (!_dataSetupComplete)
                {
                    _output.WriteLine("Setting up matrix test data...");
                    ExecuteSqlScript("matrix_test_data.sql");
                    _output.WriteLine("Matrix test data setup completed.");
                    _dataSetupComplete = true;
                }
            }
        }

        private void ExecuteSqlScript(string scriptFileName)
        {
            try
            {
                // Try multiple possible locations for the script file
                var baseDirectory = AppDomain.CurrentDomain.BaseDirectory;
                _output.WriteLine($"Base directory: {baseDirectory}");

                var possiblePaths = new[]
                {
                    // Common build output locations
                    Path.Combine(baseDirectory, "..", "..", "..", "IISFrontGuard.Module", "Scripts", scriptFileName),
                    Path.Combine(baseDirectory, "..", "..", "..", "..", "IISFrontGuard.Module", "Scripts", scriptFileName),
                    Path.Combine(baseDirectory, "Scripts", scriptFileName),
                    
                    // Direct workspace paths
                    Path.Combine(Directory.GetCurrentDirectory(), "..", "..", "..", "IISFrontGuard.Module", "Scripts", scriptFileName),
                    Path.Combine(Directory.GetCurrentDirectory(), "Scripts", scriptFileName),
                };

                string scriptPath = null;
                foreach (var path in possiblePaths)
                {
                    var fullPath = Path.GetFullPath(path);
                    _output.WriteLine($"Checking path: {fullPath}");
                    
                    if (File.Exists(fullPath))
                    {
                        scriptPath = fullPath;
                        _output.WriteLine($"✓ Found script at: {scriptPath}");
                        break;
                    }
                }

                if (scriptPath == null || !File.Exists(scriptPath))
                {
                    var errorMsg = $"ERROR: Script '{scriptFileName}' not found. Searched locations:\n" + 
                                   string.Join("\n", possiblePaths.Select(p => "  - " + Path.GetFullPath(p)));
                    _output.WriteLine(errorMsg);
                    throw new FileNotFoundException(errorMsg, scriptFileName);
                }

                // Read the script
                var script = File.ReadAllText(scriptPath);
                _output.WriteLine($"Script size: {script.Length} characters");

                // Split by GO statements (case insensitive, handles various line endings)
                var batches = System.Text.RegularExpressions.Regex.Split(
                    script, 
                    @"^\s*GO\s*$", 
                    System.Text.RegularExpressions.RegexOptions.Multiline | 
                    System.Text.RegularExpressions.RegexOptions.IgnoreCase
                );

                _output.WriteLine($"Split into {batches.Length} batches");

                using (var connection = new SqlConnection(_connectionString))
                {
                    _output.WriteLine($"Connecting to database: {connection.Database} on {connection.DataSource}");
                    connection.Open();
                    _output.WriteLine("✓ Connected successfully");

                    int batchNumber = 0;
                    int successfulBatches = 0;
                    int failedBatches = 0;

                    foreach (var batch in batches)
                    {
                        batchNumber++;
                        
                        if (string.IsNullOrWhiteSpace(batch))
                        {
                            _output.WriteLine($"Batch {batchNumber}: Skipped (empty)");
                            continue;
                        }

                        var trimmedBatch = batch.Trim();
                        if (trimmedBatch.Length == 0)
                        {
                            _output.WriteLine($"Batch {batchNumber}: Skipped (whitespace only)");
                            continue;
                        }

                        try
                        {
                            _output.WriteLine($"Executing batch {batchNumber} ({trimmedBatch.Length} chars)...");
                            
                            using (var command = new SqlCommand(trimmedBatch, connection))
                            {
                                command.CommandTimeout = 120;
                                var rowsAffected = command.ExecuteNonQuery();
                                _output.WriteLine($"✓ Batch {batchNumber} completed. Rows affected: {rowsAffected}");
                                successfulBatches++;
                            }
                        }
                        catch (SqlException ex)
                        {
                            failedBatches++;
                            _output.WriteLine($"✗ ERROR in batch {batchNumber}:");
                            _output.WriteLine($"  SQL Error: {ex.Message}");
                            _output.WriteLine($"  Error Number: {ex.Number}");
                            _output.WriteLine($"  Line Number: {ex.LineNumber}");
                            _output.WriteLine($"  Batch preview: {trimmedBatch.Substring(0, Math.Min(200, trimmedBatch.Length))}...");
                            
                            // Don't throw - continue with other batches
                        }
                    }

                    _output.WriteLine($"\n=== SCRIPT EXECUTION SUMMARY ===");
                    _output.WriteLine($"Script: {scriptFileName}");
                    _output.WriteLine($"Total batches: {batchNumber}");
                    _output.WriteLine($"Successful: {successfulBatches}");
                    _output.WriteLine($"Failed: {failedBatches}");
                    _output.WriteLine($"================================\n");

                    if (failedBatches > 0)
                    {
                        _output.WriteLine($"WARNING: {failedBatches} batch(es) failed during execution of {scriptFileName}");
                    }
                }

                _output.WriteLine($"✓ Successfully executed {scriptFileName}");
            }
            catch (FileNotFoundException fnfEx)
            {
                _output.WriteLine($"FATAL ERROR: {fnfEx.Message}");
                throw; // Re-throw to fail the test setup
            }
            catch (SqlException sqlEx)
            {
                _output.WriteLine($"FATAL SQL ERROR executing script {scriptFileName}:");
                _output.WriteLine($"  Message: {sqlEx.Message}");
                _output.WriteLine($"  Error Number: {sqlEx.Number}");
                _output.WriteLine($"  Server: {sqlEx.Server}");
                throw; // Re-throw to fail the test setup
            }
            catch (Exception ex)
            {
                _output.WriteLine($"FATAL ERROR executing script {scriptFileName}:");
                _output.WriteLine($"  Type: {ex.GetType().Name}");
                _output.WriteLine($"  Message: {ex.Message}");
                _output.WriteLine($"  Stack: {ex.StackTrace}");
                throw; // Re-throw to fail the test setup
            }
        }

        #region Helper Methods

        private class MatrixRuleInfo
        {
            public int RuleId { get; set; }
            public string RuleName { get; set; }
            public int GroupId { get; set; }
            public int ConditionId { get; set; }
            public byte FieldId { get; set; }
            public byte OperatorId { get; set; }
            public string Valor { get; set; }
            public string FieldName { get; set; }
            public bool Negate { get; set; }
        }

        private List<MatrixRuleInfo> LoadMatrixRulesFromDatabase()
        {
            var rules = new List<MatrixRuleInfo>();

            using (var connection = new SqlConnection(_connectionString))
            {
                connection.Open();
                var command = new SqlCommand(@"
                    SELECT 
                        r.Id AS RuleId,
                        r.Nombre AS RuleName,
                        g.Id AS GroupId,
                        c.Id AS ConditionId,
                        c.FieldId,
                        c.OperatorId,
                        c.Valor,
                        c.FieldName,
                        ISNULL(c.Negate, 0) AS Negate
                    FROM WafRuleEntity r
                    INNER JOIN WafGroups g ON r.Id = g.WafRuleId
                    INNER JOIN WafConditionEntity c ON g.Id = c.WafGroupId
                    WHERE r.Nombre LIKE 'TEST:%'
                    ORDER BY r.Id", connection);

                using (var reader = command.ExecuteReader())
                {
                    while (reader.Read())
                    {
                        rules.Add(new MatrixRuleInfo
                        {
                            RuleId = reader.GetInt32(0),
                            RuleName = reader.GetString(1),
                            GroupId = reader.GetInt32(2),
                            ConditionId = reader.GetInt32(3),
                            FieldId = reader.GetByte(4),
                            OperatorId = reader.GetByte(5),
                            Valor = reader.IsDBNull(6) ? "" : reader.GetString(6),
                            FieldName = reader.IsDBNull(7) ? null : reader.GetString(7),
                            Negate = reader.GetBoolean(8)
                        });
                    }
                }
            }

            return rules;
        }

        private Models.WafRule ConvertToWafRule(MatrixRuleInfo ruleInfo)
        {
            return new Models.WafRule
            {
                Id = ruleInfo.RuleId,
                Nombre = ruleInfo.RuleName,
                ActionId = 5, // Log
                Prioridad = 1000,
                Habilitado = true,
                AppId = Guid.Empty,
                Groups = new List<Models.WafGroup>
                {
                    new Models.WafGroup
                    {
                        Id = ruleInfo.GroupId,
                        Conditions = new List<Models.WafCondition>
                        {
                            new Models.WafCondition
                            {
                                Id = ruleInfo.ConditionId,
                                FieldId = ruleInfo.FieldId,
                                OperatorId = ruleInfo.OperatorId,
                                Valor = ruleInfo.Valor,
                                FieldName = ruleInfo.FieldName,
                                Negate = ruleInfo.Negate
                            }
                        }
                    }
                }
            };
        }

        #endregion


        public void Dispose()
        {
            // Cleanup test data when all tests are done
            // Note: XUnit doesn't have a perfect "run once after all tests" mechanism
            // This will run after each test class instance, but since we use a lock
            // and static flag, it should only cleanup once
            lock (_setupLock)
            {
                if (_dataSetupComplete)
                {
                    _output.WriteLine("Cleaning up matrix test data...");
                    ExecuteSqlScript("cleanup_matrix_test_data.sql");
                    _output.WriteLine("Matrix test data cleanup completed.");
                    _dataSetupComplete = false;
                }
            }
        }
    }
}
